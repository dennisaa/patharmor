<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: Container Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__drcontainers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Container Data Structures</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drvector__t.html">_drvector_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaeaba87af31694a825496218053177d64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaeaba87af31694a825496218053177d64">DRTABLE_INVALID_INDEX</a>&#160;&#160;&#160;((ptr_uint_t)-1)</td></tr>
<tr class="separator:gaeaba87af31694a825496218053177d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga75de93b82d4075650dd24e95acf164dd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drvector__t.html">_drvector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a></td></tr>
<tr class="separator:ga75de93b82d4075650dd24e95acf164dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9caff1942d844cffe52c953d448c2e6c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9caff1942d844cffe52c953d448c2e6c">hashtable_config_t</a></td></tr>
<tr class="separator:ga9caff1942d844cffe52c953d448c2e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabdc8e2396ab8607a7e4c1e5f05c588c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gabdc8e2396ab8607a7e4c1e5f05c588c3">drtable_flags_t</a> { <br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3a8a428f6ca9cdbd75e3f9807d8e03379f">DRTABLE_MEM_REACHABLE</a> = 0x1, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3adc74fb8cb16fc3a8a9fd8f898ee05d98">DRTABLE_MEM_32BIT</a> = 0x2, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggabdc8e2396ab8607a7e4c1e5f05c588c3a3a762298e3f0d70895d7ba6602e6cfbe">DRTABLE_ALLOC_COMPACT</a> = 0x4
<br/>
 }</td></tr>
<tr class="separator:gabdc8e2396ab8607a7e4c1e5f05c588c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cde78f27c3374749c462a5d58a5e38e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e">HASH_INTPTR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a">HASH_STRING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4">HASH_STRING_NOCASE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310">HASH_CUSTOM</a>
<br/>
 }</td></tr>
<tr class="separator:ga2cde78f27c3374749c462a5d58a5e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4d7584cf61da0c9d25d40a2cbdbb4f5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> { <br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5ad21f75ecfeda6b17850ce1f37cbfbfe3">DR_HASHPERS_PAYLOAD_IS_POINTER</a> = 0x0001, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5a281f8669fb41cf530d3e9b5bcefeee1a">DR_HASHPERS_CLONE_PAYLOAD</a> = 0x0002, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5a01b2e63a35d528e3aa0d1d7b94acc82d">DR_HASHPERS_REBASE_KEY</a> = 0x0004, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5acbb5b7692eb0abd2630636398a7c68b7">DR_HASHPERS_ONLY_IN_RANGE</a> = 0x0008, 
<br/>
&#160;&#160;<a class="el" href="group__drcontainers.html#ggae4d7584cf61da0c9d25d40a2cbdbb4f5aaf682665078c712befd63824f03dbd7c">DR_HASHPERS_ONLY_PERSISTED</a> = 0x0010
<br/>
 }</td></tr>
<tr class="separator:gae4d7584cf61da0c9d25d40a2cbdbb4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2eac73999ae64ce7dab8617e7c3607dd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2eac73999ae64ce7dab8617e7c3607dd">drtable_create</a> (ptr_uint_t capacity, size_t entry_size, uint flags, bool synch, void(*free_entry_func)(ptr_uint_t idx, void *entry, void *user_data))</td></tr>
<tr class="separator:ga2eac73999ae64ce7dab8617e7c3607dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b426a61810d4725391304f51efd423c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga1b426a61810d4725391304f51efd423c">drtable_alloc</a> (void *tab, ptr_uint_t num_entries, ptr_uint_t *idx_ptr)</td></tr>
<tr class="separator:ga1b426a61810d4725391304f51efd423c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72aa8dc1faa57b8ac88cd8ead4ed006"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab72aa8dc1faa57b8ac88cd8ead4ed006">drtable_destroy</a> (void *tab, void *user_data)</td></tr>
<tr class="separator:gab72aa8dc1faa57b8ac88cd8ead4ed006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1582acfe56f0ad7d8897e314aeea61fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga1582acfe56f0ad7d8897e314aeea61fd">drtable_iterate</a> (void *tab, void *iter_data, bool(*iter_func)(ptr_uint_t id, void *, void *))</td></tr>
<tr class="separator:ga1582acfe56f0ad7d8897e314aeea61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6dc346bbda6ed02e1065974242e1d4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaed6dc346bbda6ed02e1065974242e1d4">drtable_get_entry</a> (void *tab, ptr_uint_t idx)</td></tr>
<tr class="separator:gaed6dc346bbda6ed02e1065974242e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061cb4a1744b6f075a515ed43ba166fb"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga061cb4a1744b6f075a515ed43ba166fb">drtable_get_index</a> (void *tab, void *ptr)</td></tr>
<tr class="separator:ga061cb4a1744b6f075a515ed43ba166fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad164ad428e8e5d8927cd6ff0bb5566b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gad164ad428e8e5d8927cd6ff0bb5566b5">drtable_lock</a> (void *tab)</td></tr>
<tr class="separator:gad164ad428e8e5d8927cd6ff0bb5566b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138f40390422527895eda77fb2d2dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab138f40390422527895eda77fb2d2dbb">drtable_unlock</a> (void *tab)</td></tr>
<tr class="separator:gab138f40390422527895eda77fb2d2dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebd56f50630fd8e60c0a26037f8c35a"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9ebd56f50630fd8e60c0a26037f8c35a">drtable_num_entries</a> (void *tab)</td></tr>
<tr class="separator:ga9ebd56f50630fd8e60c0a26037f8c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca3d018db60aa066b151220ff9202d54"><td class="memItemLeft" align="right" valign="top">ptr_uint_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaca3d018db60aa066b151220ff9202d54">drtable_dump_entries</a> (void *tab, file_t log)</td></tr>
<tr class="separator:gaca3d018db60aa066b151220ff9202d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5206874469dc2551dad9e8f375e87df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gae5206874469dc2551dad9e8f375e87df">drvector_init</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec, uint initial_capacity, bool synch, void(*free_data_func)(void *))</td></tr>
<tr class="separator:gae5206874469dc2551dad9e8f375e87df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa578776ea720fb04c87ac04181d89f4e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa578776ea720fb04c87ac04181d89f4e">drvector_get_entry</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec, uint idx)</td></tr>
<tr class="separator:gaa578776ea720fb04c87ac04181d89f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70494a642307dd41ad8b6a754fcea9c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec, uint idx, void *data)</td></tr>
<tr class="separator:ga70494a642307dd41ad8b6a754fcea9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380b542d2b8b997ded501df7f54b6919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga380b542d2b8b997ded501df7f54b6919">drvector_append</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec, void *data)</td></tr>
<tr class="separator:ga380b542d2b8b997ded501df7f54b6919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e5949b592508c61e35ec14bfa731d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e5949b592508c61e35ec14bfa731d62">drvector_delete</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec)</td></tr>
<tr class="separator:ga2e5949b592508c61e35ec14bfa731d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1b3d3080e42bc98cddc75d675cd786"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gacf1b3d3080e42bc98cddc75d675cd786">drvector_lock</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec)</td></tr>
<tr class="separator:gacf1b3d3080e42bc98cddc75d675cd786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga752060ab72ce4d597fed7684332bba5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga752060ab72ce4d597fed7684332bba5b">drvector_unlock</a> (<a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *vec)</td></tr>
<tr class="separator:ga752060ab72ce4d597fed7684332bba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab341e9839c6cbd89a5a442df73468f5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab341e9839c6cbd89a5a442df73468f5f">stri_eq</a> (const char *s1, const char *s2)</td></tr>
<tr class="separator:gab341e9839c6cbd89a5a442df73468f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf202d20209b04c9ea9fd0657f3cfccc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaf202d20209b04c9ea9fd0657f3cfccc6">hashtable_global_config</a> (void *(*alloc_func)(size_t), void(*free_func)(void *, size_t), void(*assert_fail_func)(const char *))</td></tr>
<tr class="separator:gaf202d20209b04c9ea9fd0657f3cfccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d69f3a60f5ba9c75698649465be695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga96d69f3a60f5ba9c75698649465be695">hashtable_init</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup)</td></tr>
<tr class="separator:ga96d69f3a60f5ba9c75698649465be695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307d17165381371418414308b3eed803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex</a> (hashtable_t *table, uint num_bits, <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a> hashtype, bool str_dup, bool synch, void(*free_payload_func)(void *), uint(*hash_key_func)(void *), bool(*cmp_key_func)(void *, void *))</td></tr>
<tr class="separator:ga307d17165381371418414308b3eed803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9225a8b532a579db4f193b2a236686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2e9225a8b532a579db4f193b2a236686">hashtable_configure</a> (hashtable_t *table, <a class="el" href="group__drcontainers.html#ga9caff1942d844cffe52c953d448c2e6c">hashtable_config_t</a> *config)</td></tr>
<tr class="separator:ga2e9225a8b532a579db4f193b2a236686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6af018f2bb18648861e76bc0fdec96e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gaa6af018f2bb18648861e76bc0fdec96e">hashtable_lookup</a> (hashtable_t *table, void *key)</td></tr>
<tr class="separator:gaa6af018f2bb18648861e76bc0fdec96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cb0b8a85c6b4cdba6ee7b984aeff25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga42cb0b8a85c6b4cdba6ee7b984aeff25">hashtable_add</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr class="separator:ga42cb0b8a85c6b4cdba6ee7b984aeff25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d443ee70d3fd35d853b9697f999cbf7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga3d443ee70d3fd35d853b9697f999cbf7">hashtable_add_replace</a> (hashtable_t *table, void *key, void *payload)</td></tr>
<tr class="separator:ga3d443ee70d3fd35d853b9697f999cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8972b42e34447e229489ab120271dbfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8972b42e34447e229489ab120271dbfd">hashtable_remove</a> (hashtable_t *table, void *key)</td></tr>
<tr class="separator:ga8972b42e34447e229489ab120271dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9699afdfaab140f2e98b7783a51b19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga4a9699afdfaab140f2e98b7783a51b19">hashtable_remove_range</a> (hashtable_t *table, void *start, void *end)</td></tr>
<tr class="separator:ga4a9699afdfaab140f2e98b7783a51b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcb10d265f6005bbcef89129ad58548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga2bcb10d265f6005bbcef89129ad58548">hashtable_clear</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga2bcb10d265f6005bbcef89129ad58548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e402d49c64df6809c82483a8ddd6770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga9e402d49c64df6809c82483a8ddd6770">hashtable_delete</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga9e402d49c64df6809c82483a8ddd6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ba198cad4e146607e8a07db005b514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga98ba198cad4e146607e8a07db005b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f9e88180c79d080113e2bec858dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock</a> (hashtable_t *table)</td></tr>
<tr class="separator:ga8d7f9e88180c79d080113e2bec858dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac15c2ca65b95597ff2311f1040f1be53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gac15c2ca65b95597ff2311f1040f1be53">hashtable_lock_self_owns</a> (hashtable_t *table)</td></tr>
<tr class="separator:gac15c2ca65b95597ff2311f1040f1be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d52ff455ac9bab9ef5ffe49586e904"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size</a> (void *drcontext, hashtable_t *table, size_t entry_size, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags)</td></tr>
<tr class="separator:gab3d52ff455ac9bab9ef5ffe49586e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012f1fb1127c60d90bd76d662c3dbf4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist</a> (void *drcontext, hashtable_t *table, size_t entry_size, file_t fd, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags)</td></tr>
<tr class="separator:ga012f1fb1127c60d90bd76d662c3dbf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5857998e61b2477997fad25adf71580b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect</a> (void *drcontext, byte **map, hashtable_t *table, size_t entry_size, void *perscxt, <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a> flags, bool(*process_payload)(void *key, void *payload, ptr_int_t shift))</td></tr>
<tr class="separator:ga5857998e61b2477997fad25adf71580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaeaba87af31694a825496218053177d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRTABLE_INVALID_INDEX&#160;&#160;&#160;((ptr_uint_t)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid index of drtable </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga75de93b82d4075650dd24e95acf164dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drvector__t.html">_drvector_t</a>  <a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The storage for a vector. </p>

</div>
</div>
<a class="anchor" id="ga9caff1942d844cffe52c953d448c2e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__hashtable__config__t.html">_hashtable_config_t</a>  <a class="el" href="group__drcontainers.html#ga9caff1942d844cffe52c953d448c2e6c">hashtable_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration parameters for a hashtable. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gabdc8e2396ab8607a7e4c1e5f05c588c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#gabdc8e2396ab8607a7e4c1e5f05c588c3">drtable_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used for drtable_create </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabdc8e2396ab8607a7e4c1e5f05c588c3a8a428f6ca9cdbd75e3f9807d8e03379f"></a>DRTABLE_MEM_REACHABLE</em>&#160;</td><td class="fielddoc">
<p>allocated table entries must be reachable from code cache </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabdc8e2396ab8607a7e4c1e5f05c588c3adc74fb8cb16fc3a8a9fd8f898ee05d98"></a>DRTABLE_MEM_32BIT</em>&#160;</td><td class="fielddoc">
<p>Allocates table entries from the addresss space that can be converted to a 32-bit int. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabdc8e2396ab8607a7e4c1e5f05c588c3a3a762298e3f0d70895d7ba6602e6cfbe"></a>DRTABLE_ALLOC_COMPACT</em>&#160;</td><td class="fielddoc">
<p>Allocates table entries as compactly as possible, which may return indics in a random order. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2cde78f27c3374749c462a5d58a5e38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of hash key </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38ea7e83c8ad190fd19419c301ace3bcbe2e"></a>HASH_INTPTR</em>&#160;</td><td class="fielddoc">
<p>A pointer-sized integer or pointer </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38ea3a57810af6552f1efcda7a6abddbe92a"></a>HASH_STRING</em>&#160;</td><td class="fielddoc">
<p>A case-sensitive string </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38eae0b0e4c68e2bab129d1d2a6ff43d44d4"></a>HASH_STRING_NOCASE</em>&#160;</td><td class="fielddoc">
<p>A case-insensitive string </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2cde78f27c3374749c462a5d58a5e38eaa90b8cffea02e8d64d001982ddb0c310"></a>HASH_CUSTOM</em>&#160;</td><td class="fielddoc">
<p>A custom key. Hash and compare operations must be provided in <a class="el" href="group__drcontainers.html#ga307d17165381371418414308b3eed803">hashtable_init_ex()</a>. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae4d7584cf61da0c9d25d40a2cbdbb4f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to control hashtable persistence </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5ad21f75ecfeda6b17850ce1f37cbfbfe3"></a>DR_HASHPERS_PAYLOAD_IS_POINTER</em>&#160;</td><td class="fielddoc">
<p>Valid for <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a> and the same value must be passed to both. Treats payloads as pointers to allocated memory. By default payloads are treated as inlined values if this flag is not set. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5a281f8669fb41cf530d3e9b5bcefeee1a"></a>DR_HASHPERS_CLONE_PAYLOAD</em>&#160;</td><td class="fielddoc">
<p>Valid for <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>. Only applies if DR_HASHPERS_KEY_IS_POINTER. Performs a shallow clone of the payload upon resurrection. If this flag is not set, the payloads will remain pointing into the mapped file. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5a01b2e63a35d528e3aa0d1d7b94acc82d"></a>DR_HASHPERS_REBASE_KEY</em>&#160;</td><td class="fielddoc">
<p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a>, <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>, and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>, and the same value must be passed to all. Only applies if keys are of type HASH_INTPTR. Adjusts each key by the difference in the persist-time start address of the persisted code region and the resurrected start address. The value of this flag must match across all three calls <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a>, <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>, and <a class="el" href="group__drcontainers.html#ga5857998e61b2477997fad25adf71580b">hashtable_resurrect()</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5acbb5b7692eb0abd2630636398a7c68b7"></a>DR_HASHPERS_ONLY_IN_RANGE</em>&#160;</td><td class="fielddoc">
<p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and the same value must be passed to both. Only applies if keys are of type HASH_INTPTR. Only persists entries whose key is in the address range being persisted. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae4d7584cf61da0c9d25d40a2cbdbb4f5aaf682665078c712befd63824f03dbd7c"></a>DR_HASHPERS_ONLY_PERSISTED</em>&#160;</td><td class="fielddoc">
<p>Valid for <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> and the same value must be passed to both. Only applies if keys are of type HASH_INTPTR. Only persists entries for which <a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable()</a> returns true. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1b426a61810d4725391304f51efd423c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t *&#160;</td>
          <td class="paramname"><em>idx_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory for an array of <code>num_entries</code> table entries, and returns a pointer to the allocated memory. Returns NULL if fails. If <code>idx_ptr</code> is not NULL, the index for the first entry is returned in <code>idx_ptr</code>, and all the entries from the same allocation can be referred to as index + n. </p>

</div>
</div>
<a class="anchor" id="ga2eac73999ae64ce7dab8617e7c3607dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_create </td>
          <td>(</td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(ptr_uint_t idx, void *entry, void *user_data)&#160;</td>
          <td class="paramname"><em>free_entry_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a drtable with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>The approximate number of entries for the table. The capacity is only a suggestion for better memory usage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry, which should be greater than 0 and smaller than USHRT_MAX (65535). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The flags to specify the features of the table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the table's lock is initialized and can be used via <a class="el" href="group__drcontainers.html#gad164ad428e8e5d8927cd6ff0bb5566b5">drtable_lock()</a> and <a class="el" href="group__drcontainers.html#gab138f40390422527895eda77fb2d2dbb">drtable_unlock()</a>, allowing the caller to extend synchronization beyond just the operation in question. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_entry_func</td><td>The callback for freeing each table entry. Leave it NULL if no callback is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab72aa8dc1faa57b8ac88cd8ead4ed006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the table. The <code>user_data</code> is passed to each <code>free_entry_func</code> if specified. </p>

</div>
</div>
<a class="anchor" id="gaca3d018db60aa066b151220ff9202d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_dump_entries </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dumps all the table entries as an array into a file in binary format. There is no header add, so the user should add one if so desired. Returns the number of entries dumped. </p>

</div>
</div>
<a class="anchor" id="gaed6dc346bbda6ed02e1065974242e1d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drtable_get_entry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_uint_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the entry at index <code>idx</code>. Returns NULL if the entry for <code>idx</code> is not allocated. </p>

</div>
</div>
<a class="anchor" id="ga061cb4a1744b6f075a515ed43ba166fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_get_index </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an index to the entry pointed at by <code>ptr</code>. Returns DRTABLE_INVALID_INDEX if <code>ptr</code> does not point to any allocated entries. </p>

</div>
</div>
<a class="anchor" id="ga1582acfe56f0ad7d8897e314aeea61fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_iterate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iter_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ptr_uint_t id, void *, void *)&#160;</td>
          <td class="paramname"><em>iter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over entries in the table and call the callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tab</td><td>The drtable to be operated on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_data</td><td>Iteration data passed to <code>iter_func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_func</td><td>The callback for iterating each table entry. Returns false to stop iterating. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad164ad428e8e5d8927cd6ff0bb5566b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the table lock. </p>

</div>
</div>
<a class="anchor" id="ga9ebd56f50630fd8e60c0a26037f8c35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ptr_uint_t drtable_num_entries </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of entries in the table. </p>

</div>
</div>
<a class="anchor" id="gab138f40390422527895eda77fb2d2dbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drtable_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the table lock. </p>

</div>
</div>
<a class="anchor" id="ga380b542d2b8b997ded501df7f54b6919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry to the end of the vector, resizing it if necessary. If <a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry()</a> has been called, this will add to the index beyond the last index passed to <a class="el" href="group__drcontainers.html#ga70494a642307dd41ad8b6a754fcea9c8">drvector_set_entry()</a>. </p>

</div>
</div>
<a class="anchor" id="ga2e5949b592508c61e35ec14bfa731d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the vector. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="gaa578776ea720fb04c87ac04181d89f4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* drvector_get_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the entry at index <code>idx</code>. For an unsychronized table, the caller is free to directly access the <code>array</code> field of <code>vec</code>. </p>

</div>
</div>
<a class="anchor" id="gae5206874469dc2551dad9e8f375e87df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>initial_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_data_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a drvector with the given parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>The vector to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_capacity</td><td>The initial number of entries allocated for the vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the vector's lock is initialized and can be used via vector_lock() and vector_unlock(), allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_data_func</td><td>A callback for freeing each data item. Leave it NULL if no callback is needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf1b3d3080e42bc98cddc75d675cd786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the vector lock. </p>

</div>
</div>
<a class="anchor" id="ga70494a642307dd41ad8b6a754fcea9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool drvector_set_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the entry at index <code>idx</code> to <code>data</code>. For an unsychronized table, the caller is free to directly set the <code>array</code> field of <code>vec</code>. Entries in between the last set index and <code>idx</code> are left uninitialized. Returns whether successful. </p>

</div>
</div>
<a class="anchor" id="ga752060ab72ce4d597fed7684332bba5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void drvector_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga75de93b82d4075650dd24e95acf164dd">drvector_t</a> *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the vector lock. </p>

</div>
</div>
<a class="anchor" id="ga42cb0b8a85c6b4cdba6ee7b984aeff25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_add </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry. Returns false if an entry for <code>key</code> already exists. </p>
<dl class="section note"><dt>Note</dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d443ee70d3fd35d853b9697f999cbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_add_replace </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new entry, replacing an existing entry if any. Returns the old payload, or NULL if there was no existing entry. </p>
<dl class="section note"><dt>Note</dt><dd>Never use NULL as a payload as that is used for a lookup failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bcb10d265f6005bbcef89129ad58548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_clear </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all entries from the table. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="ga2e9225a8b532a579db4f193b2a236686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_configure </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga9caff1942d844cffe52c953d448c2e6c">hashtable_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures optional parameters of hashtable operation. </p>

</div>
</div>
<a class="anchor" id="ga9e402d49c64df6809c82483a8ddd6770"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_delete </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys all storage for the table, including all entries and the table itself. If free_payload_func was specified calls it for each payload. </p>

</div>
</div>
<a class="anchor" id="gaf202d20209b04c9ea9fd0657f3cfccc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_global_config </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t)&#160;</td>
          <td class="paramname"><em>alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, size_t)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const char *)&#160;</td>
          <td class="paramname"><em>assert_fail_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The hashtable has parametrized heap and assert routines for flexibility. This routine must be called BEFORE any other hashtable_ routine; else, the defaults will be used. </p>

</div>
</div>
<a class="anchor" id="ga96d69f3a60f5ba9c75698649465be695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&#160;</td>
          <td class="paramname"><em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>str_dup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a hashtable with the given size, hash type, and whether to duplicate string keys. All operations are synchronized by default. </p>

</div>
</div>
<a class="anchor" id="ga307d17165381371418414308b3eed803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_init_ex </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#ga2cde78f27c3374749c462a5d58a5e38e">hash_type_t</a>&#160;</td>
          <td class="paramname"><em>hashtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>str_dup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_payload_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint(*)(void *)&#160;</td>
          <td class="paramname"><em>hash_key_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *, void *)&#160;</td>
          <td class="paramname"><em>cmp_key_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a hashtable with the given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>The hashtable to be initialized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_bits</td><td>The initial number of bits to use for the hash key which determines the initial size of the table itself. The result of the hash function will be truncated to this size. This size will be increased when the table is resized (resizing always doubles the size). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashtype</td><td>The type of hash to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str_dup</td><td>Whether to duplicate string keys. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synch</td><td>Whether to synchronize each operation. Even when <code>synch</code> is false, the hashtable's lock is initialized and can be used via <a class="el" href="group__drcontainers.html#ga98ba198cad4e146607e8a07db005b514">hashtable_lock()</a> and <a class="el" href="group__drcontainers.html#ga8d7f9e88180c79d080113e2bec858dbf">hashtable_unlock()</a>, allowing the caller to extend synchronization beyond just the operation in question, to include accessing a looked-up payload, e.g. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">free_payload_func</td><td>A callback for freeing each payload. Leave it NULL if no callback is needed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_key_func</td><td>A callback for hashing a key. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. The hash operation can return a full uint, as its result will be truncated via a mod of the hash key bit size. This allows for resizing the table without changing the hash operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_key_func</td><td>A callback for comparing two keys. Leave it NULL if no callback is needed and the default is to be used. For HASH_CUSTOM, a callback must be provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98ba198cad4e146607e8a07db005b514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_lock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires the hashtable lock. </p>

</div>
</div>
<a class="anchor" id="gac15c2ca65b95597ff2311f1040f1be53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_lock_self_owns </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the hashtable lock is owned by the calling thread. This routine is only available in debug builds. In release builds it always returns true. </p>

</div>
</div>
<a class="anchor" id="gaa6af018f2bb18648861e76bc0fdec96e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* hashtable_lookup </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the payload for the given key, or NULL if the key is not found </p>

</div>
</div>
<a class="anchor" id="ga012f1fb1127c60d90bd76d662c3dbf4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_persist </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>These routines assume that the caller is synchronizing across the call to <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>. If these are called using DR's persistence interface, DR guarantees synchronization.</p>
<p><a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> must be called immediately prior to calling <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The table to persist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The target persisted file handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3d52ff455ac9bab9ef5ffe49586e904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashtable_persist_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>These routines assume that the caller is synchronizing across the call to <a class="el" href="group__drcontainers.html#gab3d52ff455ac9bab9ef5ffe49586e904">hashtable_persist_size()</a> and <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a>. If these are called using DR's persistence interface, DR guarantees synchronization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The table to persist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8972b42e34447e229489ab120271dbfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the entry for key. If free_payload_func was specified calls it for the payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a class="anchor" id="ga4a9699afdfaab140f2e98b7783a51b19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_remove_range </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all entries with key in [start..end). If free_payload_func was specified calls it for each payload being removed. Returns false if no such entry exists. </p>

</div>
</div>
<a class="anchor" id="ga5857998e61b2477997fad25adf71580b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hashtable_resurrect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__drcontainers.html#gae4d7584cf61da0c9d25d40a2cbdbb4f5">hasthable_persist_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *key, void *payload, ptr_int_t shift)&#160;</td>
          <td class="paramname"><em>process_payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For use persisting a table of single-alloc entries (i.e., via a shallow copy) for loading into a live table later.</p>
<p>Reads in entries from disk and adds them to the live table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The opaque DR context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapped-in persisted file, pointing at the data written by <a class="el" href="group__drcontainers.html#ga012f1fb1127c60d90bd76d662c3dbf4a">hashtable_persist()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>The live table to add to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>The size of each table entry payload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perscxt</td><td>The opaque persistence context from DR's persist events </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Controls various aspects of the persistence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">process_payload</td><td>If non-NULL, calls process_payload instead of hashtable_add. process_payload can then adjust the paylod and if it wishes invoke hashtable_add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d7f9e88180c79d080113e2bec858dbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashtable_unlock </td>
          <td>(</td>
          <td class="paramtype">hashtable_t *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases the hashtable lock. </p>

</div>
</div>
<a class="anchor" id="gab341e9839c6cbd89a5a442df73468f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stri_eq </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caseless string compare </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 5.0.0 --- Wed Sep 10 2014 21:36:20 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
